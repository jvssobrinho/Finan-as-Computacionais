# -*- coding: utf-8 -*-
"""Análise de indicadores Econômicos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xiGBqeiTgZBZz30G2OzzojLfpObIzwKl

<a href="https://colab.research.google.com/github/ricospeloacaso/python_para_investimentos/blob/master/03_CORRELA%C3%87%C3%83O_entre_D%C3%93LAR_e_IBOVESPA_Python_para_Investimentos.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# 1. Importando bibliotecas
"""

!pip install ipeadatapy

"""1. Faça um gráfico combinando os dados da SELIC, Ibov (ˆBVSP), dólar (USDBRL=X) e inflação (IPCA) para o período 2015 a 2025."""

#!pip install yfinance --upgrade --no-cache-dir

!pip install python-bcb

import ssl

ssl._create_default_https_context = ssl._create_unverified_context
import pandas_datareader.data as web

from scipy.stats import zscore
import plotly.express as px
import datetime

def busca_titulos_tesouro_direto():
  url = 'https://www.tesourotransparente.gov.br/ckan/dataset/df56aa42-484a-4a59-8184-7676580c81e3/resource/796d2059-14e9-44e3-80c9-2d9e30b405c1/download/PrecoTaxaTesouroDireto.csv'
  df  = pd.read_csv(url, sep=';', decimal=',')
  df['Data Vencimento'] = pd.to_datetime(df['Data Vencimento'], dayfirst=True)
  df['Data Base']       = pd.to_datetime(df['Data Base'], dayfirst=True)
  multi_indice = pd.MultiIndex.from_frame(df.iloc[:, :3])
  df = df.set_index(multi_indice).iloc[: , 3:]
  return df
def busca_vendas_tesouro():
  url = "https://www.tesourotransparente.gov.br/ckan/dataset/f0468ecc-ae97-4287-89c2-6d8139fb4343/resource/e5f90e3a-8f8d-4895-9c56-4bb2f7877920/download/VendasTesouroDireto.csv"
  df  = pd.read_csv(url, sep=';', decimal=',')
  df['Vencimento do Titulo'] = pd.to_datetime(df['Vencimento do Titulo'], dayfirst=True)
  df['Data Venda']       = pd.to_datetime(df['Data Venda'], dayfirst=True)
  multi_indice = pd.MultiIndex.from_frame(df.iloc[:, :3])
  df = df.set_index(multi_indice).iloc[: , 3:]
  return df
def busca_recompras_tesouro():
  url = "https://www.tesourotransparente.gov.br/ckan/dataset/f30db6e4-6123-416c-b094-be8dfc823601/resource/30c2b3f5-6edd-499a-8514-062bfda0f61a/download/RecomprasTesouroDireto.csv"
  df  = pd.read_csv(url, sep=';', decimal=',')
  df['Vencimento do Titulo'] = pd.to_datetime(df['Vencimento do Titulo'], dayfirst=True)
  df['Data Resgate']       = pd.to_datetime(df['Data Resgate'], dayfirst=True)
  multi_indice = pd.MultiIndex.from_frame(df.iloc[:, :3])
  df = df.set_index(multi_indice).iloc[: , 3:]
  return df

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
# Seaborn é uma biblioteca usada principalmente para plotagem estatística em  Python.
# Construída em cima do Matplotlib
#!pip install --upgrade seaborn
import seaborn as sns
import ipeadatapy as idpy
import warnings
from bcb import sgs
warnings.simplefilter(action='ignore', category=FutureWarning)





"""# 2. Obtendo e tratando os dados"""

start = "2015-07-12"
tickers = "^BVSP USDBRL=X"
carteira = yf.download(tickers, start=start)["Close"]

selic = sgs.get({'selic':432}, start = start)
ipca = sgs.get({'Índice nacional de preços ao consumidor-amplo (IPCA)':433}, start = start'



selic

ipca

ipca = ipca.resample('D').ffill()



# A função pandas.DataFrame.dropna() remove os valores nulos (valores ausentes, Nan, Nat) do DataFrame,
#retirando as linhas ou colunas que contêm os valores nulos.
carteira = carteira.dropna()
carteira

carteira.columns = ["DOLAR", "IBOV"]

carteira['SELIC'] = selic['selic']
carteira['IPCA'] = ipca['Índice nacional de preços ao consumidor-amplo (IPCA)']



carteira

import matplotlib.pyplot as plt

# Supondo que 'carteira' está pronto e o índice é a data
# carteira.set_index('Date', inplace=True)

# 1. Criar a figura e o primeiro eixo (ax1)
fig, ax1 = plt.subplots(figsize=(14, 8))

# 2. Plotar IBOV no primeiro eixo (ax1, à esquerda)
ax1.plot(carteira.index, carteira['IBOV'], color='blue', label='IBOV (Eixo Esquerdo)')
ax1.set_xlabel('Data')
ax1.set_ylabel('Pontos IBOV', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')
ax1.grid(True, which='both', linestyle='--')

# 3. Criar um segundo eixo (ax2) que compartilha o mesmo eixo X
ax2 = ax1.twinx()

# 4. Plotar DOLAR e SELIC no segundo eixo (ax2, à direita)
ax2.plot(carteira.index, carteira['DOLAR'], color='green', label='DOLAR (Eixo Direito)')
ax2.plot(carteira.index, carteira['SELIC'], color='red', label='SELIC (Eixo Direito)')
ax2.set_ylabel('Valor (R$ / %)', color='black')
ax2.tick_params(axis='y', labelcolor='black')

# 5. Adicionar um título geral e uma legenda única
plt.title('Variação de Ativos (com Eixo Duplo)', fontsize=16)
fig.legend(loc="upper left", bbox_to_anchor=(0.1, 0.9))

# Ajusta o layout para garantir que tudo fique visível
fig.tight_layout()

# Mostra o gráfico
plt.show()

import pandas as pd
from scipy.stats import pearsonr
from datetime import datetime


carteira.index = pd.to_datetime(carteira.index)


hoje = pd.Timestamp.now()
um_ano_atras = hoje - pd.DateOffset(years=1)

dados_ultimo_ano = carteira.loc[um_ano_atras:hoje]


dados_limpos = dados_ultimo_ano[['IBOV', 'SELIC']].dropna()

print(f"Analisando {len(dados_limpos)} pontos de dados de {um_ano_atras.date()} até {hoje.date()}.\n")


# Usando o método .corr() do pandas para uma visualização rápida
correlacao_simples = dados_limpos.corr()
print("--- Matriz de Correlação (Último Ano) ---")
print(correlacao_simples)
print("-" * 40)


ibov = dados_limpos['IBOV']
selic = dados_limpos['SELIC']

# Realizar o teste de correlação de Pearson
# Retorna: (coeficiente de correlação, p-valor)
corr_coef, p_value = pearsonr(ibov, selic)

print("\n--- Teste de Hipótese para a Correlação ---")
print(f"Coeficiente de Correlação de Pearson: {corr_coef:.4f}")
print(f"P-valor: {p_value}")
print("-" * 40)

# --- PASSO 4: INTERPRETAÇÃO DO RESULTADO ---
print("\n--- Conclusão do Teste de Hipótese ---")

# Nível de significância (alpha) comum é 0.05 (5%)
alpha = 0.05

# Definindo as hipóteses:
# H₀ (Hipótese Nula): A correlação verdadeira entre IBOV e SELIC é zero.
# H₁ (Hipótese Alternativa): A correlação verdadeira é diferente de zero.

if p_value < alpha:
    print(f"Resultado: Rejeitamos a Hipótese Nula (p-valor < {alpha}).")
    print("Conclusão: A correlação observada é ESTATISTICAMENTE SIGNIFICATIVA.")
    print("Isso significa que é muito improvável que a relação encontrada seja fruto do acaso.")
else:
    print(f"Resultado: Não conseguimos rejeitar a Hipótese Nula (p-valor >= {alpha}).")
    print("Conclusão: A correlação observada NÃO é estatisticamente significativa.")
    print("Não há evidências estatísticas fortes para afirmar que existe uma relação entre as variáveis.")

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt


colunas_analise = ['DOLAR', 'IBOV', 'SELIC', 'IPCA']
dados_para_correlacao = carteira[colunas_analise]


#CALCULAR A MATRIZ DE CORRELAÇÃO ---
correlation_matrix = dados_para_correlacao.corr()

print("--- Matriz de Correlação ---")
print(correlation_matrix)


#VISUALIZAR A MATRIZ COM UM HEATMAP ---
plt.figure(figsize=(10, 8)) # Define o tamanho da figura

sns.heatmap(
    correlation_matrix,
    annot=True,        # Mostra os valores de correlação dentro de cada célula
    cmap='coolwarm',   # Escolhe uma paleta de cores (vermelho=positivo, azul=negativo)
    fmt=".2f",         # Formata os números para duas casas decimais
    linewidths=.5      # Adiciona uma pequena linha entre as células
)

plt.title('Matriz de Correlação das Variáveis da Carteira', fontsize=16)
plt.show()



"""## Análise da Matriz de Correlação

A matriz de correlação revela a relação linear entre os principais ativos da carteira no período analisado. As conclusões a seguir são baseadas nos coeficientes calculados, que medem a direção e a força do movimento conjunto entre as variáveis.

### Relações entre os Ativos

A relação mais proeminente é a **correlação positiva e forte de `+0.78` entre o DOLAR e o IBOV**. Isso indica que, na maior parte do tempo, esses dois ativos se moveram na mesma direção. Uma alta do Dólar tendeu a ser acompanhada por uma alta no Ibovespa, e vice-versa. Esse comportamento pode ser explicado pela crescente "dolarização" do índice, onde empresas com grande peso (como Vale, Petrobras e outras exportadoras) se beneficiam diretamente de um dólar mais forte, impulsionando seus resultados e, consequentemente, o valor de suas ações. Na prática, isso significa que ter Dólar e IBOV na mesma carteira **não ofereceu uma boa diversificação** durante este período, pois ambos estiveram expostos a riscos semelhantes.

Por outro lado, a **correlação entre IBOV e SELIC foi fraca e negativa, com um valor de `-0.21`**. Essa é a relação econômica clássica, onde taxas de juros mais altas (SELIC) tendem a tornar a renda fixa mais atrativa, potencialmente retirando capital da bolsa (renda variável) e pressionando o IBOV para baixo. O fato de a correlação ser fraca sugere que, embora essa dinâmica exista, outros fatores tiveram um impacto mais dominante. Ainda assim, essa relação negativa valida a estratégia de diversificação tradicional, onde a renda fixa atrelada à SELIC serve como um contraponto à volatilidade da bolsa.

A correlação entre **DOLAR e SELIC foi praticamente inexistente, registrando `-0.13`**. Embora a teoria econômica sugira que uma SELIC mais alta possa atrair capital estrangeiro e fortalecer o Real (pressionando o Dólar para baixo), a realidade é que o preço do dólar é influenciado por uma gama muito mais ampla de fatores globais e domésticos, tornando essa relação fraca e pouco confiável para fins estratégicos.

Finalmente, as correlações do **IPCA com as demais variáveis foram muito próximas de zero**. Isso é esperado, pois a inflação mensal é um indicador macroeconômico que reflete o passado e serve de base para decisões futuras de política monetária (como a própria SELIC), mas não se move em sincronia com os mercados financeiros no curto prazo. Sua influência é, portanto, indireta.

### Conclusões Estratégicas

*   **Principal Insight:** A forte correlação positiva entre Dólar e IBOV mostra que, no período analisado, eles não funcionaram como ativos de diversificação um para o outro. Pelo contrário, se comportaram como um bloco de risco único.
*   **Diversificação Clássica:** A relação negativa (ainda que fraca) entre SELIC e IBOV reforça que a combinação de renda fixa e renda variável continua sendo uma estratégia de diversificação fundamental.
*   **Papel da Inflação:** O IPCA não deve ser visto como um gatilho direto para os movimentos de mercado, mas sim como o principal fator que influencia as decisões sobre a taxa SELIC, que, por sua vez, impacta a atratividade da bolsa.
"""

titulos = busca_titulos_tesouro_direto()

titulos.sort_index(inplace=True)
titulos

tipos_titulos = titulos.index.droplevel(level=1).droplevel(level=1).drop_duplicates().to_list()
tipos_titulos

pre2028 = titulos.loc[('Tesouro Prefixado', '2028-01-01')]
pre2028

selic

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

pre2028_plot = pre2028.reset_index()
pre2028_plot['Data Base'] = pd.to_datetime(pre2028_plot['Data Base'])
pre2028_plot.set_index('Data Base', inplace=True)

# Para o DataFrame 'carteira' (onde está a SELIC)
carteira.index = pd.to_datetime(carteira.index)



start_date = pre2028_plot.index.min()
end_date = pre2028_plot.index.max()

# Filtra o DataFrame 'carteira' para conter apenas os dados nesse mesmo período.
selic_filtrada = carteira.loc[start_date:end_date]


#CRIAR O GRÁFICO ---
fig, ax = plt.subplots(figsize=(15, 8))

# Plotar a Taxa do Tesouro Prefixado 2028
ax.plot(pre2028_plot.index, pre2028_plot['Taxa Compra Manha'], label='Taxa Tesouro Prefixado 2028', color='royalblue', linewidth=2.0)

# Plotar a Taxa SELIC
ax.plot(selic_filtrada.index, selic_filtrada['SELIC'], label='Taxa SELIC', color='red', linestyle='--')


# MELHORAR A VISUALIZAÇÃO ---
ax.set_title('Taxa do Tesouro Prefixado 2028 vs. Taxa SELIC', fontsize=18)
ax.set_xlabel('Data', fontsize=12)
ax.set_ylabel('Taxa de Juros (%)', fontsize=12)


ax.legend(fontsize=12)

ax.grid(True, which='both', linestyle='--', linewidth=0.5)


ax.xaxis.set_major_locator(mdates.AutoDateLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y')) # Ex: Jan 2025
plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')


plt.tight_layout()

plt.show()

"""### Análise do Gráfico: Expectativas do Mercado vs. Política Monetária

Este gráfico ilustra a dinâmica entre a política monetária atual e as expectativas do mercado financeiro. A linha azul contínua, representando a taxa do Tesouro Prefixado 2028, reflete a aposta do mercado sobre o futuro dos juros, enquanto a linha vermelha tracejada, a Taxa SELIC, mostra a realidade presente definida pelo Banco Central.

No início do período, a taxa prefixada se posiciona consistentemente acima da SELIC, sinalizando que os investidores já antecipavam a necessidade de um aperto monetário para controlar a inflação. Essa expectativa se materializa quando a SELIC de fato sobe em degraus, em movimentos que o mercado, através da volatilidade da linha azul, já havia precificado.

O ponto de inflexão mais revelador ocorre na segunda metade do gráfico. Após o ciclo de altas da SELIC, a taxa do Tesouro Prefixado cruza para baixo da taxa básica, um fenômeno conhecido como inversão da curva de juros. Essa inversão é um forte indicativo de que o mercado, apesar de lidar com uma SELIC alta no presente, já projeta um cenário de cortes no futuro. A percepção é que o pico dos juros foi atingido e que, para reestimular a economia adiante, o Banco Central precisará reduzir a taxa.

Em suma, o gráfico demonstra que a taxa prefixada age como um termômetro das expectativas, olhando sempre à frente. Ela não apenas reage à política atual, mas ativamente a antecipa, oferecendo uma visão valiosa sobre o consenso do mercado a respeito da trajetória de médio e longo prazo dos juros no país.
"""

#import pandas as pd
import yfinance as yf
import pandas_datareader.data as web
import matplotlib.pyplot as plt
from datetime import datetime


try:
    start = datetime(2015, 7, 12) # Pegando um período longo para ver os ciclos
    end = datetime.now()

    # S&P 500 do Yahoo Finance
    sp500_series = yf.download('^SPX', start=start, end=end, progress=False)['Close']
    sp500_series.name = 'S&P 500'

    # CPI e Fed Funds Rate do FRED
    cpi_series = web.DataReader('CPIAUCSL', 'fred', start, end)['CPIAUCSL']
    cpi_series.name = 'CPI'
    fed_funds_series = web.DataReader('DFF', 'fred', start, end)['DFF']
    fed_funds_series.name = 'Fed Funds Rate'

    print("Dados dos EUA carregados com sucesso!")
except Exception as e:
    print(f"Erro ao carregar os dados: {e}")


#UNIR E LIMPAR OS DADOS ---
df_usa = pd.concat([sp500_series, cpi_series, fed_funds_series], axis=1)
df_usa.ffill(inplace=True) # Preenche os dados mensais para os dias úteis
df_usa.dropna(inplace=True)
#CRIAR O GRÁFICO DE EIXO DUPLO ---
fig, ax1 = plt.subplots(figsize=(15, 8))

# Plotar S&P 500 no eixo esquerdo (ax1)
ax1.set_xlabel('Data')
ax1.set_ylabel('Pontos S&P 500', color='blue', fontsize=12)
ax1.plot(df_usa.index, df_usa['^SPX'], color='blue', label='S&P 500 (Eixo Esquerdo)')


ax1.tick_params(axis='y', labelcolor='blue')

# Criar um segundo eixo que compartilha o eixo X
ax2 = ax1.twinx()

# Plotar Fed Funds Rate no eixo direito (ax2)
ax2.set_ylabel('Taxa de Juros (%)', color='red', fontsize=12)
ax2.plot(df_usa.index, df_usa['Fed Funds Rate'], color='red', linestyle='--', label='Fed Funds Rate (Eixo Direito)')

ax2.tick_params(axis='y', labelcolor='red')


plt.title('Mercado de Ações (S&P 500) vs. Política de Juros (Fed Funds)', fontsize=16)
fig.legend(loc="upper left", bbox_to_anchor=(0.1, 0.9)) # Legenda unificada
ax1.grid(True, linestyle='--')
fig.tight_layout()
plt.show()

df_usa.plot(
    subplots=True,
    figsize=(14, 12),
    layout=(3, 1),
    title='Análise Macroeconômica dos EUA',
    grid=True,
    sharex=True
)
plt.tight_layout(rect=[0, 0.03, 1, 0.97])
plt.show()

carteira

dados_para_correlacao

df_limpo = dados_para_correlacao.dropna()

print("Formato dos dados originais:", dados_para_correlacao.shape)
print("Formato dos dados após remover valores ausentes (NaN):", df_limpo.shape)

correlacoes = df_limpo[['DOLAR', 'IBOV', 'SELIC', 'IPCA']].corr()
print("Matriz de Correlação:")
print(correlacoes)
print("\n")


# Configura o estilo dos gráficos para ficar mais agradável
sns.set_theme(style="whitegrid")

# Cria uma figura com 3 subplots (1 linha, 3 colunas)
fig, axes = plt.subplots(1, 3, figsize=(20, 6))

# Título geral para a figura
fig.suptitle('Análise de Correlação entre Ativos Financeiros', fontsize=16)

# Gráfico 1: SELIC vs. IBOV
sns.regplot(data=df_limpo, x='SELIC', y='IBOV', ax=axes[0])
axes[0].set_title('Correlação: SELIC vs. IBOV')
axes[0].set_xlabel('Taxa SELIC (%)')
axes[0].set_ylabel('Pontos IBOVESPA')

# Gráfico 2: SELIC vs. IPCA
sns.regplot(data=df_limpo, x='SELIC', y='IPCA', ax=axes[1])
axes[1].set_title('Correlação: SELIC vs. IPCA')
axes[1].set_xlabel('Taxa SELIC (%)')
axes[1].set_ylabel('IPCA (%)')

# Gráfico 3: Dólar vs. SELIC
sns.regplot(data=df_limpo, x='DOLAR', y='SELIC', ax=axes[2])
axes[2].set_title('Correlação: Dólar vs. SELIC')
axes[2].set_xlabel('Cotação do Dólar (R$)')
axes[2].set_ylabel('Taxa SELIC (%)')

# Ajusta o layout para evitar sobreposição de títulos
plt.tight_layout(rect=[0, 0, 1, 0.96]) # O rect ajusta para o suptitle não sobrepor

# Exibe os gráficos
plt.show()