# -*- coding: utf-8 -*-
"""Algoritmo de pair Trading.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XhDf-s7HNs3ceFW8_IOiplg9v1uQU8pq
"""

# Importa as bibliotecas
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

from pandas_datareader import data as pdr
!pip install yfinance
import yfinance as yf
import statsmodels
import statsmodels.api as sm
from statsmodels.tsa.stattools import coint

# Busca os preços de fechamento
ticker = ['ITSA4.SA', 'ITUB4.SA']
start = '2020-01-01'
end = '2025-06-06'

data = yf.download(ticker, start=start, end=end)['Close']

"""Analisando a correlação entre os ativos e cointegração"""

corr_ativos = data['ITSA4.SA'].corr(data['ITUB4.SA'])

# Realiza o teste de cointegração

score, pvalue, _ = coint(data['ITSA4.SA'], data['ITUB4.SA'], maxlag = 1)
print(' Teste p-valor da Cointegração ' + str(pvalue))

"""
## O que é Cointegração?

A cointegração é um conceito estatístico que indica se duas ou mais séries temporais não estacionárias possuem uma combinação linear estacionária. Em termos mais simples, se dois ativos são cointegrados, eles tendem a se mover juntos no longo prazo, mesmo que suas trajetórias individuais sejam divergentes no curto prazo. Isso é particularmente útil para estratégias de *pairs trading*.

## Hipóteses do Teste de Cointegração

No contexto do teste de cointegração, as hipóteses nula ($H_0$) e alternativa ($H_A$) são definidas da seguinte forma:

* **Hipótese Nula ($H_0$):** As séries **não** são cointegradas. Isso significa que não há uma relação de equilíbrio de longo prazo entre os ativos.
* **Hipótese Alternativa ($H_A$):** As séries **são** cointegradas. Isso implica que existe uma relação de equilíbrio de longo prazo entre os ativos.


Como o Teste p-valor da Cointegração  foi 0.010034693528027805, rejeitamos a Hipótese Nula de que as séries não são cointegradas, então há evidência estatistica de que são cointegradas, a 5% de significância
"""

corr_ativos

"""Correlação positiva quase perfeita (0,97) , ótimos candidatos para pair trade"""

# Verifica o comportamento das duas séries
data.plot(figsize=(15,10))

corr_ativos = data['ITSA4.SA'].corr(data['ITUB4.SA'])

"""Modelagem do Spread entre os ativos"""

# Adiciona a constante
const_ITSA4 = sm.add_constant(data['ITSA4.SA'])

# Roda a regressão
results_reg = sm.OLS(data['ITUB4.SA'], const_ITSA4).fit()

# Transforma em série

ITSA = data['ITSA4.SA']

ITUB = data['ITUB4.SA']

# Calcula o spread

b = results_reg.params['ITSA4.SA']

spread = ITUB - b * ITSA

spread

# Cria a função para calcular o z-score

def zscore(series):
    return (series - series.mean()) / np.std(series)

# Plota o z-score

zscore(spread).plot(figsize=(15,10))
plt.axhline(zscore(spread).mean(), color='black')
plt.axhline(1.0, color='red', linestyle='--')
plt.axhline(-1.0, color='green', linestyle='--')
plt.legend(['Spread z-score', 'Média', '+1', '-1']);

ITSA = data['ITSA4.SA']

ITUB = data['ITUB4.SA']

# Cria um df para os sinais de trade
sinais = pd.DataFrame()
sinais['ITSA4'] = ITSA
sinais['ITUB4'] = ITUB
ratios = sinais.ITSA4 / sinais.ITUB4

# Calcula o z-score e define os limites superiores e inferiores
sinais['z'] = zscore(ratios)
sinais['z_limite_superior'] = np.mean(sinais['z']) + np.std(sinais['z'])
sinais['z_limite_inferior'] = np.mean(sinais['z']) - np.std(sinais['z'])

# Cria o sinal - vendido se o z-score é maior que o limite superior, senão comprado
sinais['sinais1'] = 0
sinais['sinais1'] = np.select([sinais['z'] > \
                                 sinais['z_limite_superior'], sinais['z'] < sinais['z_limite_inferior']], [-1, 1], default=0)

# Diferencia em primeira ordem para obter a posição da ação
sinais['positions1'] = sinais['sinais1'].diff()
sinais['sinais2'] = -sinais['sinais1']
sinais['positions2'] = sinais['sinais2'].diff()



plt.figure(figsize=(15,10))

plt.plot(portfolio['total'])



"""Cálculo do Drawdown"""

portfolio['peak'] = portfolio['total'].cummax()

# 2. Calcular o drawdown

portfolio['drawdown'] = (portfolio['total'] - portfolio['peak']) / portfolio['peak']


max_drawdown = portfolio['drawdown'].min()

print(f"Máximo Drawdown (MDD): {max_drawdown:.4%}")


plt.figure(figsize=(12, 6))
plt.plot(portfolio.index, portfolio['total'], label='Valor Total do Portfólio')
plt.plot(portfolio.index, portfolio['peak'], label='Pico Acumulado', linestyle='--')
plt.fill_between(portfolio.index, portfolio['total'], portfolio['peak'], where=portfolio['total'] < portfolio['peak'], color='red', alpha=0.3, label='Drawdown')
plt.title('Valor do Portfólio e Drawdown')
plt.xlabel('Data')
plt.ylabel('Valor')
plt.legend()
plt.grid(True)
plt.show()

plt.figure(figsize=(12, 4))
plt.plot(portfolio.index, portfolio['drawdown'] * 100, label='Drawdown (%)', color='red')
plt.title('Drawdown Percentual do Portfólio')
plt.xlabel('Data')
plt.ylabel('Drawdown (%)')
plt.grid(True)
plt.show()



"""Índice Sharpe"""

portfolio['retornos_diarios'] = portfolio['total'].pct_change()

# Remover NaNs que podem surgir do pct_change (a primeira linha será NaN)
portfolio = portfolio.dropna()

# 2. Definir a taxa livre de risco anualizada
# Usando a Selic como proxy, atualmente em 14.75% ao ano (referência: Junho de 2025).
taxa_livre_risco_anual = 0.1475

taxa_livre_risco_diaria = (1 + taxa_livre_risco_anual)**(1/252) - 1

# 3. Calcular o retorno médio diário do portfólio
retorno_medio_diario_portfolio = portfolio['retornos_diarios'].mean()

# 4. Calcular o desvio padrão (volatilidade) dos retornos diários do portfólio
desvio_padrao_diario_portfolio = portfolio['retornos_diarios'].std()

# 5. Calcular o Índice Sharpe anualizado

retorno_anualizado_portfolio = (1 + retorno_medio_diario_portfolio)**252 - 1
desvio_padrao_anualizado_portfolio = desvio_padrao_diario_portfolio * np.sqrt(252)

indice_sharpe = (retorno_anualizado_portfolio - taxa_livre_risco_anual) / desvio_padrao_anualizado_portfolio

print(f"Índice Sharpe Anualizado: {indice_sharpe:.4f}")

"""# Interpretação do Índice Sharpe

O **Índice Sharpe** é uma das métricas mais importantes na análise de desempenho de investimentos, pois avalia o retorno de um ativo ou portfólio em relação ao risco que ele assume. Ele é calculado da seguinte forma:

$$ Sharpe \: Ratio = \frac{Retorno \: do \: Portfólio - Taxa \: Livre \: de \: Risco}{Desvio \: Padrão \: do \: Portfólio} $$

Onde:
* **Retorno do Portfólio:** O retorno médio gerado pelo investimento.
* **Taxa Livre de Risco:** O retorno de um investimento "sem risco" (ex: Selic no Brasil, Treasury Bills nos EUA).
* **Desvio Padrão do Portfólio:** A volatilidade ou risco do investimento.

## O que significa um Índice Sharpe de -7.6037?

Um Índice Sharpe negativo, como -7.6037, é um sinal muito importante e geralmente **indesejável** no mundo dos investimentos. Ele indica que:

1.  **Retorno Abaixo da Taxa Livre de Risco:** O principal motivo para um Sharpe Ratio negativo é que o retorno médio do seu portfólio foi **inferior** à taxa de retorno de um investimento considerado livre de risco durante o período analisado.
2.  **Perdas ou Ganhos Insuficientes:** Isso pode significar que o portfólio teve perdas significativas, ou que, mesmo que tenha tido pequenos ganhos, esses ganhos não foram suficientes para superar o que você obteria simplesmente aplicando o dinheiro em um investimento "seguro" (como a Selic no Brasil).
3.  **Não Compensa o Risco Assumido:** O número negativo significa que, para cada unidade de risco que você assumiu com este portfólio, você obteve um retorno *pior* do que se tivesse apenas investido no ativo livre de risco. Em outras palavras, o risco não foi recompensado; ao contrário, ele levou a um desempenho inferior.

## Implicações Práticas:


Em resumo, um Índice Sharpe de -7.6037 é um forte indicativo de que a estratégia pairs trading não está gerando retornos adequados em relação ao risco que está assumindo, e é inferior ao que se obteria em um investimento livre de risco (investindo em rendas fixas).
"""

